// Generated by CoffeeScript 1.12.7
(function() {
  var root;

  root = (typeof self === 'object' && self.self === self && self) || (typeof global === 'object' && global.global === global && global);

  root.Fractal = (function() {
    function Fractal(selector, fragment, colors) {
      var $canvas;
      $canvas = $(selector);
      this.canvas = $canvas[0];
      this.ctx = this.canvas.getContext('2d');
      this.fragment = fragment || [[1]];
      this.params = {
        width: $canvas.width(),
        height: $canvas.height(),
        size: this.fragment.length
      };
      this.canvas.width = this.params.width;
      this.canvas.height = this.params.height;
    }

    Fractal.prototype.rgba = function(r, g, b, a) {
      var ref;
      if (_.isArray(r)) {
        ref = r, r = ref[0], g = ref[1], b = ref[2], a = ref[3];
      }
      return "rgba(" + (r || 0) + "," + (g || 0) + "," + (b || 0) + "," + (a || 1) + ")";
    };

    Fractal.prototype.clear = function() {
      this.ctx.clearRect(0, 0, this.params.width, this.params.height);
      this.ctx.fillStyle = this.rgba(0, 0, 0, 1);
      return this.ctx.fillRect(0, 0, this.params.width, this.params.height);
    };

    Fractal.prototype.draw = function(callback) {
      var call, count, fractal, iterations;
      fractal = this;
      iterations = this._computeIterations();
      this.fragment = this._normalizeFragment(this.fragment, iterations.length);
      count = iterations.length;
      call = function(i) {
        if (i == null) {
          i = 0;
        }
        return setTimeout(function() {
          return fractal.iteration(0, iterations[i], iterations, function() {
            count--;
            if (iterations[i + 1]) {
              call(i + 1);
            }
            if (count <= 0) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        }, 0);
      };
      return call();
    };

    Fractal.prototype.iteration = function(i, iteration, iterations, callback) {
      var fractal;
      if (i == null) {
        i = 0;
      }
      fractal = this;
      return setTimeout(function() {
        var j;
        j = 0;
        while (j <= iteration.countY) {
          fractal.figure(i, j, iteration.size);
          j++;
        }
        i++;
        if (i <= iteration.countX) {
          return fractal.iteration(i, iteration, iterations, callback);
        }
        return typeof callback === "function" ? callback() : void 0;
      }, 800 / iteration.countX);
    };

    Fractal.prototype.figure = function(iX, iY, iSize, size) {
      var column, i, j, k, len, point, pointSize, ref, results;
      if (size == null) {
        size = this.params.size;
      }
      pointSize = Math.floor(iSize / size);
      ref = this.fragment;
      results = [];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        column = ref[i];
        results.push((function() {
          var l, len1, results1;
          results1 = [];
          for (j = l = 0, len1 = column.length; l < len1; j = ++l) {
            point = column[j];
            this.ctx.fillStyle = point;
            results1.push(this.ctx.fillRect(iX * iSize + i * pointSize, iY * iSize + j * pointSize, pointSize, pointSize));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Fractal.prototype._computeIterations = function() {
      var addIter, height, iterations, ref, size, width;
      iterations = [];
      ref = this.params, width = ref.width, height = ref.height, size = ref.size;
      console.log(width, height, size);
      addIter = function() {
        var countX, countY;
        countX = Math.floor(width / size);
        countY = Math.floor(height / size);
        if (countX > 0 && countY > 0) {
          iterations.push({
            size: size,
            countX: countX,
            countY: countY
          });
          size *= 2;
          return addIter();
        } else {
          return iterations;
        }
      };
      addIter();
      return iterations;
    };

    Fractal.prototype._normalizeFragment = function(fragment, iterations) {
      var alpha, normal;
      if (iterations == null) {
        iterations = 1;
      }
      alpha = (1 / iterations).toFixed(2);
      normal = _.map(fragment, (function(_this) {
        return function(column) {
          return _.map(column, function(point) {
            var color;
            if (_.isArray(point)) {
              color = point.slice(0, 3);
              color.push(alpha);
            } else if (point) {
              color = [255, 255, 255, alpha];
            } else {
              color = [0, 0, 0, alpha];
            }
            return _this.rgba(color);
          });
        };
      })(this));
      return normal;
    };

    return Fractal;

  })();

}).call(this);
